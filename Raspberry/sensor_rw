"""
Dominik Fiegl 06.2024
Program to start the gRPC server based on the server.proto file.
The server listens on port 50051 for incoming requests.
Is meant to be implemented to the main file of the SGAS project:
logging.basicConfig()
server = serve()
threading.Thread(target=server.wait_for_termination).start()
"""
from concurrent import futures
import grpc
import logging
import server_pb2_grpc
import server_pb2
import threading

class sgas_serviceServicer(server_pb2_grpc.sgas_serviceServicer):
    def new_sensor_request(self, request, context):
        _name = request.name
        _type = request.type
        _pin = request.pin
        _addr = request.addr
        GPIOsensor(name=_name, pin=_pin, sensorId=None, type=_type, addr=_addr)
        return server_pb2.done_message()

    def delete_sensor_request(self, request, context):
        _sensorId = request.sensorId
        #call function to delete sensor
        return server_pb2.done_message()

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=1))
    server_pb2_grpc.add_sgas_serviceServicer_to_server(sgas_serviceServicer(), server)
    server.add_insecure_port('[::]:50051')
    server.start()
    return server

logging.basicConfig()
server = serve()
threading.Thread(target=server.wait_for_termination).start()

import database_orm as db
import datetime
import time

#GPIO setup
import RPi.GPIO as GPIO

sensorList = []
init_state = True

def add_to_db(_sensorId, _name, _type, _pin, _addr):
    if not init_state:
        temp = db.sensor(name=_name, type=_type, pin=_pin, addr=_addr)
        temp.save()
        return temp.sensorId
    else:
        return _sensorId
    
class GPIOsensor():
    def __init__(self, name, pin, sensorId=None, type='GPIO', addr=''):
        self.name = name
        self.pin = pin
        self.type = type
        self.addr = addr
        #append the sensor to the list of sensors (adds instance)
        sensorList.append(self)
        #save the sensor to the database
        self.sensorId = add_to_db(sensorId, self.name, self.type, self.pin, self.addr)
        #specific setup
        GPIO.setup(int(self.pin), GPIO.IN)
    
    def getinf(self):
        return (self.sensorId, GPIO.input(int(self.pin)), datetime.datetime.now()) 

def update_sensors_to_db():
    for item in sensorList:
        #create a row in the sensorValue table and saves it
        info = item.getinf()
        dbwrite = db.sensorValue(sensorId=info[0], value=info[1], time_stamp=info[2])
        dbwrite.save()
        

try:
    GPIO.setmode(GPIO.BCM)
    # Connect to the database
    db.database.connect()
    # Retrieve the sensor values from the database
    initialSensors = db.sensor.select().order_by(db.sensor.sensorId)
    # Close the database connection
    for sensor in initialSensors:
        # Create a new sensor object
        GPIOsensor(name=sensor.name, pin=sensor.pin, sensorId=sensor.sensorId, type=sensor.type, addr=sensor.addr)
        # Add the sensor object to the list of sensors

    init_state = False

    while(True):
        update_sensors_to_db()
        time.sleep(1)

except(KeyboardInterrupt):
    print("Interrupted by user. Shutting down...")
    GPIO.cleanup()
    db.close()